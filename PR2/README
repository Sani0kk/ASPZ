# Практична робота №2: Дослідження `time_t` та сегментів пам’яті

## Мета роботи
Дослідити момент закінчення `time_t` на 32- та 64-бітних архітектурах і вплив ініціалізації масиву на розташування даних у сегментах пам’яті виконуваного файлу.

## Завдання 2.1: Визначення моменту закінчення `time_t`

### Опис
Програма визначає розмір типу `time_t`, його максимальне значення та прогнозує дату закінчення для 32- та 64-бітних систем.

### Код програми

```c
// Вставте код із файлу /home/san/PR2/task2_1.c
```

*Примітка*: Скопіюйте вміст файлу `/home/san/PR2/task2_1.c` і вставте його в цей блок коду.

### Компіляція та виконання
У терміналі Slim виконайте:
```sh
cd /home/san/PR2
gcc -o task2_1 task2_1.c
./task2_1
```

### Результат виконання
Очікуваний вивід залежить від архітектури:
- Для 32-бітної системи:
  ```
  Розмір time_t: 4 байт
  Максимальне значення time_t (32-біт): 2147483647
  Дата закінчення: 19 січня 2038 року, 03:14:07 UTC
  ```
- Для 64-бітної системи:
  ```
  Розмір time_t: 8 байт
  Максимальне значення time_t (64-біт): 9223372036854775807
  Дата закінчення: дуже далеко в майбутньому
  ```

### Скріншот виконання
![Скріншот виконання task2_1](task2_1_screenshot.png)

*Примітка*: 
- У терміналі Slim виконайте компіляцію (`gcc -o task2_1 task2_1.c`) та запуск (`./task2_1`).
- Зробіть скріншот терміналу, де видно команду компіляції, запуск і вивід.
- Збережіть скріншот як `task2_1_screenshot.png` у директорії `/home/san/PR2`.

### Аналіз сегментів
Виконайте:
```sh
size task2_1
```

Приклад виводу:
```
text    data     bss     dec     hex filename
1234     567     890    2681    a79 task2_1
```

### Скріншот аналізу сегментів
![Скріншот аналізу сегментів task2_1](task2_1_size_screenshot.png)

*Примітка*:
- Виконайте `size task2_1`.
- Зробіть скріншот виводу.
- Збережіть як `task2_1_size_screenshot.png` у `/home/san/PR2`.

## Завдання 2.2: Ініціалізація масиву та сегменти пам’яті

### Опис
Досліджуємо, як ініціалізація масиву впливає на сегменти пам’яті (`data` чи `bss`) у виконуваному файлі.

### Код програми (неініціалізований масив)

```c
// Вставте код із файлу /home/san/PR2/task2_2_uninitialized.c
```

*Примітка*: Скопіюйте вміст файлу `/home/san/PR2/task2_2_uninitialized.c` і вставте його в цей блок коду.

### Код програми (ініціалізований масив)

```c
// Вставте код із файлу /home/san/PR2/task2_2_initialized.c
```

*Примітка*: Скопіюйте вміст файлу `/home/san/PR2/task2_2_initialized.c` і вставте його в цей блок коду.

### Компіляція та виконання
Для обох програм:
```sh
cd /home/san/PR2
gcc -o task2_2_uninitialized task2_2_uninitialized.c
./task2_2_uninitialized
gcc -o task2_2_initialized task2_2_initialized.c
./task2_2_initialized
```

### Результат виконання
- Для `task2_2_uninitialized`:
  ```
  Масив без ініціалізації
  ```
- Для `task2_2_initialized`:
  ```
  Масив з ініціалізацією
  ```

### Скріншот виконання
![Скріншот виконання task2_2](task2_2_screenshot.png)

*Примітка*:
- Скомпілюйте та запустіть обидві програми.
- Зробіть скріншот терміналу, де видно команди компіляції, запуск і вивід для обох програм.
- Збережіть як `task2_2_screenshot.png` у `/home/san/PR2`.

### Аналіз сегментів
Виконайте:
```sh
size task2_2_uninitialized
size task2_2_initialized
```

Приклад виводу:
- Для `task2_2_uninitialized`:
  ```
  text    data     bss     dec     hex filename
  1234     567    4000    5801    16a9 task2_2_uninitialized
  ```
- Для `task2_2_initialized`:
  ```
  text    data     bss     dec     hex filename
  1234    4567     890    6891    1aeb task2_2_initialized
  ```

### Скріншот аналізу сегментів
![Скріншот аналізу сегментів task2_2](task2_2_size_screenshot.png)

*Примітка*:
- Виконайте `size task2_2_uninitialized` та `size task2_2_initialized`.
- Зробіть скріншот виводу.
- Збережіть як `task2_2_size_screenshot.png` у `/home/san/PR2`.

## Висновок
- Завдання 2.1 показало, що `time_t` на 32-бітних системах обмежено 19 січня 2038 року через 32-бітне ціле число, тоді як на 64-бітних системах проблема відсувається на мільярди років.
