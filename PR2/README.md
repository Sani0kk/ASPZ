# Практична робота №2: Дослідження `time_t` та сегментів пам’яті

## Мета роботи
Дослідити момент закінчення типу `time_t` на 32- та 64-бітних архітектурах, а також вплив ініціалізації масиву на розташування даних у сегментах пам’яті виконуваного файлу.

## Завдання 2.1: Визначення моменту закінчення `time_t` (Загальне завдання)

### Опис
Програма визначає розмір типу `time_t`, його максимальне значення та дату закінчення для 32- та 64-бітних систем.

### Код програми
```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

int main() {
    printf("Розмір time_t: %zu байт\n", sizeof(time_t));
    if (sizeof(time_t) == 4) {
        printf("Максимальне значення time_t (32-біт): %ld\n", (long)INT_MAX);
        printf("Дата закінчення: 19 січня 2038 року, 03:14:07 UTC\n");
    } else if (sizeof(time_t) == 8) {
        printf("Максимальне значення time_t (64-біт): %lld\n", (long long)LLONG_MAX);
        printf("Дата закінчення: дуже далеко в майбутньому\n");
    }
    return 0;
}
```

### Результат виконання
Очікуваний вивід залежить від архітектури системи:

| Архітектура | Вивід |
|-------------|-------|
| 32-бітна    | Розмір time_t: 4 байт<br>Максимальне значення time_t (32-біт): 2147483647<br>Дата закінчення: 19 січня 2038 року, 03:14:07 UTC |
| 64-бітна    | Розмір time_t: 8 байт<br>Максимальне значення time_t (64-біт): 9223372036854775807<br>Дата закінчення: дуже далеко в майбутньому |

### Скріншот виконання
![Скріншот виконання task2_1](task2_1.png)

### Аналіз сегментів

Приклад виводу:
| Сегмент | Розмір (байт) | Опис |
|---------|---------------|------|
| text    | 1234          | Сегмент коду |
| data    | 567           | Ініціалізовані дані |
| bss     | 890           | Неініціалізовані дані |
| dec     | 2681          | Загальний розмір |
| hex     | a79           | Шістнадцяткове значення |

### Скріншот аналізу сегментів
![Скріншот аналізу сегментів task2_1](task2_1_size.png)

## Завдання 2.2: Ініціалізація масиву та сегменти пам’яті (Варіант 3)

### Опис
Досліджуємо вплив ініціалізації масиву на розташування даних у сегментах `data` або `bss`.

### Код програми (неініціалізований масив)
```c
#include <stdio.h>

int array[1000];

int main() {
    printf("Масив без ініціалізації\n");
    return 0;
}
```

### Код програми (ініціалізований масив)
```c
#include <stdio.h>

int array[1000] = {0};

int main() {
    printf("Масив з ініціалізацією\n");
    return 0;
}
```

### Результат виконання
| Програма                | Вивід                     |
|-------------------------|---------------------------|
| task2_2_u   | Масив без ініціалізації   |
| task2_2_i     | Масив з ініціалізацією    |

### Скріншот виконання
![Скріншот виконання task2_2](task2_2_screenshot.png)

### Аналіз сегментів

Приклад виводу:
| Файл                     | text | data | bss  | dec  | hex  |
|--------------------------|------|------|------|------|------|
| task2_2_uninitialized    | 1234 | 567  | 4000 | 5801 | 16a9 |
| task2_2_initialized      | 1234 | 4567 | 890  | 6891 | 1aeb |

### Скріншот аналізу сегментів
![Скріншот аналізу сегментів task2_2](task2_2_size_screenshot.png)

## Висновок
- У завданні 2.1 встановлено, що `time_t` на 32-бітних системах обмежено 19 січня 2038 року через переповнення 32-бітного цілого числа, тоді як 64-бітні системи не мають цієї проблеми в найближчому майбутньому.
- У завданні 2.2 виявлено, що неініціалізовані масиви розміщуються в сегменті `bss`, а ініціалізовані — у сегменті `data`, що впливає на розмір виконуваного файлу.
