# Практична робота №2: Дослідження `time_t` та сегментів пам’яті

## Мета роботи
Дослідити момент закінчення типу `time_t` на 32- та 64-бітних архітектурах, а також вплив ініціалізації масиву на розташування даних у сегментах пам’яті виконуваного файлу.

## Завдання 2.1: Визначення моменту закінчення `time_t`

### Опис
Програма визначає розмір типу `time_t`, його максимальне значення та дату закінчення для 32- та 64-бітних систем.

### Код програми
```c
// Вставте код із файлу task2_1.c
```

### Компіляція та виконання
У терміналі Slim виконайте:
```sh
cd /home/san/PR2
gcc -o task2_1 task2_1.c
./task2_1
```

### Результат виконання
Очікуваний вивід залежить від архітектури системи:

| Архітектура | Вивід |
|-------------|-------|
| 32-бітна    | Розмір time_t: 4 байт<br>Максимальне значення time_t (32-біт): 2147483647<br>Дата закінчення: 19 січня 2038 року, 03:14:07 UTC |
| 64-бітна    | Розмір time_t: 8 байт<br>Максимальне значення time_t (64-біт): 9223372036854775807<br>Дата закінчення: дуже далеко в майбутньому |

### Скріншот виконання
![Скріншот виконання task2_1](task2_1_screenshot.png)

### Аналіз сегментів
Виконайте:
```sh
size task2_1
```

Приклад виводу:
| Сегмент | Розмір (байт) | Опис |
|---------|---------------|------|
| text    | 1234          | Сегмент коду |
| data    | 567           | Ініціалізовані дані |
| bss     | 890           | Неініціалізовані дані |
| dec     | 2681          | Загальний розмір |
| hex     | a79           | Шістнадцяткове значення |

### Скріншот аналізу сегментів
![Скріншот аналізу сегментів task2_1](task2_1_size_screenshot.png)

## Завдання 2.2: Ініціалізація масиву та сегменти пам’яті

### Опис
Досліджуємо вплив ініціалізації масиву на розташування даних у сегментах `data` або `bss`.

### Код програми (неініціалізований масив)
```c
// Вставте код із файлу task2_2_uninitialized.c
```

### Код програми (ініціалізований масив)
```c
// Вставте код із файлу task2_2_initialized.c
```

### Компіляція та виконання
Для обох програм виконайте:
```sh
cd /home/san/PR2
gcc -o task2_2_uninitialized task2_2_uninitialized.c
./task2_2_uninitialized
gcc -o task2_2_initialized task2_2_initialized.c
./task2_2_initialized
```

### Результат виконання
| Програма                | Вивід                     |
|-------------------------|---------------------------|
| task2_2_uninitialized   | Масив без ініціалізації   |
| task2_2_initialized     | Масив з ініціалізацією    |

### Скріншот виконання
![Скріншот виконання task2_2](task2_2_screenshot.png)

### Аналіз сегментів
Виконайте:
```sh
size task2_2_uninitialized
size task2_2_initialized
```

Приклад виводу:
| Файл                     | text | data | bss  | dec  | hex  |
|--------------------------|------|------|------|------|------|
| task2_2_uninitialized    | 1234 | 567  | 4000 | 5801 | 16a9 |
| task2_2_initialized      | 1234 | 4567 | 890  | 6891 | 1aeb |

### Скріншот аналізу сегментів
![Скріншот аналізу сегментів task2_2](task2_2_size_screenshot.png)

## Висновок
- У завданні 2.1 встановлено, що `time_t` на 32-бітних системах обмежено 19 січня 2038 року через переповнення 32-бітного цілого числа, тоді як 64-бітні системи не мають цієї проблеми в найближчому майбутньому.
- У завданні 2.2 виявлено, що неініціалізовані масиви розміщуються в сегменті `bss`, а ініціалізовані — у сегменті `data`, що впливає на розмір виконуваного файлу.
